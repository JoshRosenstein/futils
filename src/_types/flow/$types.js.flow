//@flow
//https://github.com/anvilabs/flow-libdefs/blob/master/definitions/lodash.js
type MatchesIterateeType<K: string> = {+[key: K]: any};
type MatchesPropertyIterateeType<K: string | number> = [K, any];

type Record<K=Property, T=any> = {
  +[K]: T;
};

type IterateeType<V, K: string | number = string | number, R = any> =
  | ((val: V) => R)
  | MatchesIterateeType<K>
  | MatchesPropertyIterateeType<K>
  | string
  | number;

  type PredicateType<
  V,
  K: string | number = string,
  R: boolean = *,
> = IterateeType<V, K, R>

export interface ArrayLike<T> {
  + length: number;
  + [n: number]: T;
}



// From @types/ramda
export type Property = string | number | Symbol
export type Path = List<Property>;
export type PropKey = Property
//export type Constructor<T> = new (...args: any[]) => T;
export type Morphism<T, U> = (value: T) => U;

export type NestedMorphism<T, U, V> = (value: T) => (value: U) => V;
export type IndexedListMorphism<T, U> = (value: T, index: number, list: List<T>) => U;
export type IndexedObjectMorphism<T, U, K: PropKey> = (value: T, index: number, object: Record<K, T>) => U;
export type KeyedObjectMorphism<T, U, K : PropKey> = (value: T, key: K, object: Record<K, T>) => U;
export type Tap<T> = (value: T) => void;
export type KeyedObjectTap<T, U = Dictionary<T>> = (value: T, key: string, object: U) => void;
export type Predicate<T> = Morphism<T, boolean>;


export type Comparator<T, U: number | boolean> = (a: T, b: T) => U;
export type Variadic<R> = (...args: any[]) => R;
export type TypedVariadic<T, R> = (...args: T[]) => R;
export type ListMapper<T, U> = (fn: Morphism<T, U>, list: List<T>) => U[];
export type ObjectMapper<T, U, K : string> = (fn: Morphism<T, U>, object: Record<K, T>) => Record<K, U>;
export type KeyValuePair<K, V>=ArrayLike<K | V> | Array<[K,V]>/// Flow doesnt support numeric

export type List<T> = T[] | ArrayLike<T>;
export type NestedList<T> = List<T | List<T> | List<List<T>>>;
export interface Dictionary<T> {
    [key: string]: T;
}
export interface NestedDictionary<T> {
    [key: string]: T | NestedDictionary<T>;
}
export interface Ordered {
    valueOf(): string | number | boolean;
}
export interface Tuple {
  //  0: any;
    +[index: number]: any;
    +length: number;
}

export interface Filterable<T> {
    filter(fn: Predicate<T>): Filterable<T>;
}
export interface Functor<T> {
    map<U>(fn: Morphism<T, U>): Functor<U>;
}
export interface Apply<T> extends Functor<T> {
    ap<U>(fn: Apply<Morphism<T, U>>): Apply<U>;
}
export interface Chain<T> extends Apply<T> {
    chain<U>(fn: Morphism<T, Chain<U>>): Chain<U>;
}
export interface Applicative<T> extends Apply<T> {
    of<U>(value: U): Applicative<U>;
}
export interface Foldable<T> {
    reduce<U>(fn: (accumulator: U, value: T) => U, initial: U): U;
}
export interface Traversable<T> extends Functor<T>, Foldable<T> {
    traverse<U, V>(fn: Morphism<T, Applicative<U>>, of: Morphism<V, Applicative<V>>): Applicative<Traversable<U>>;
}
